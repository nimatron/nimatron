/*
 * This file is based on example provided by the IntelliJ Platform SDK DevGuide.
 * Copyright 2000-2020 JetBrains s.r.o. and other contributors.
 * Use of original example source code is governed by the Apache 2.0 license.
 *
 * Copyright 2020 TiePy Ltd. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This file is part of Nimatron, a Nim plug-in for IDEA platform IDEs.
 *
 * Nimatron is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.  TiePy Ltd designates this
 * particular file as subject to the "Classpath" exception as provided
 * by TiePy Ltd in the LICENSE file that accompanied this code.
 *
 * Nimatron is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Nimatron.  If not, see <https://www.gnu.org/licenses/>.
 *
 * Please contact TiePy Ltd, 19 Lyall Way, Laurencekirk, AB30 1FU, UK
 * or visit www.tiepy.com if you need additional information or have any
 * questions.
 */

{
  parserClass="com.tiepy.nimatron.parser.NimParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Nim"
  psiImplClassSuffix="Impl"
  psiPackage="com.tiepy.nimatron.parser"
  psiImplPackage="com.tiepy.nimatron.parser.impl"

  elementTypeHolderClass="com.tiepy.nimatron.parser.NimTypes"
  elementTypeClass="com.tiepy.nimatron.psi.NimElementType"
  tokenTypeClass="com.tiepy.nimatron.psi.NimTokenType"

  tokens = [
    BRACKET="BRACKET"
    PARENTHESIS="PARENTHESIS"
    C_SEMICOLON="C_SEMICOLON"
    C_COMMA="C_COMMA"
    C_GRAVE_ACCENT="C_GRAVE_ACCENT"
  ]

  psiImplUtilClass="com.tiepy.nimatron.parser.impl.NimPsiImplUtil"
}

module ::= (stmt ((';'|IND_EQ) stmt)*)?
comma ::= ',' COMMENT?
semicolon ::= ';' COMMENT?
colon ::= ':' COMMENT?
colcom ::= ':' COMMENT?
operator ::= OP0|OP1|OP2|OP3|OP4|OP5|OP6|OP7|OP8|OP9|'from'|'static'|'..'
prefixOperator ::= operator
optInd ::= COMMENT? (IND_GT|IND_EQ)?
optPar ::= (IND_GT|IND_EQ)?
simpleExpr ::= arrowExpr (OP0 optInd arrowExpr)* pragma?
arrowExpr ::= assignExpr (OP1 optInd assignExpr)*
assignExpr ::= orExpr (OP2 optInd orExpr)*
orExpr ::= andExpr (OP3 optInd andExpr)*
andExpr ::= cmpExpr (OP4 optInd cmpExpr)*
cmpExpr ::= sliceExpr (OP5 optInd sliceExpr)*
sliceExpr ::= ampExpr (OP6 optInd ampExpr)*
ampExpr ::= plusExpr (OP7 optInd plusExpr)*
plusExpr ::= mulExpr (OP8 optInd mulExpr)*
mulExpr ::= dollarExpr (OP9 optInd dollarExpr)*
dollarExpr ::= primary (OP10 optInd primary)*
symbol ::= '`' (KEYW|IDENT|literal|(operator|'('|')'|'['|']'|'{'|'}'|'=')+)+ '`'|IDENT|KEYW
exprColonEqExpr ::= expr (':'|'=' expr)?
exprList ::= expr (comma expr)*
exprColonEqExprList2 ::= exprColonEqExpr (comma exprColonEqExpr)* (comma)?
qualifiedIdent ::= symbol ('.' optInd symbol)?
setOrTableConstr ::= '{' ((exprColonEqExpr comma)+|':' ) '}'
castExpr ::= 'cast' '[' optInd typeDesc optPar ']' '(' optInd expr optPar ')'
parKeyw ::= 'discard'|'include'|'if'|'while'|'case'|'try'|'finally'|'except'|'for'|'block'|'const'|'let'|'when'|'var'|'mixin'
par ::= '(' optInd ( parKeyw complexOrSimpleStmt (';' complexOrSimpleStmt)*
            | ';' complexOrSimpleStmt (';' complexOrSimpleStmt)*
            | pragmaStmt
            | simpleExpr ( ('=' expr (';' complexOrSimpleStmt (';' complexOrSimpleStmt)* )? )
                         | (':' expr (',' exprColonEqExpr (',' exprColonEqExpr)* )? ) ) ) optPar ')'
literal ::= INT_LIT|INT8_LIT|INT16_LIT|INT32_LIT|INT64_LIT
            |UINT_LIT|UINT8_LIT|UINT16_LIT|UINT32_LIT|UINT64_LIT
            |FLOAT_LIT|FLOAT32_LIT|FLOAT64_LIT
            |STR_LIT|RSTR_LIT|TRIPLESTR_LIT
            |CHAR_LIT
            |NIL
generalizedLit ::= GENERALIZED_STR_LIT|GENERALIZED_TRIPLESTR_LIT
identOrLiteral ::= generalizedLit|symbol|literal|par|arrayConstr|setOrTableConstr|castExpr
arrayConstr ::= '[' optInd (exprColonEqExpr comma?)* optPar ']'
primarySuffix ::= '(' (exprColonEqExpr comma?)* ')'
        | '.' optInd symbol generalizedLit?
        | '[' optInd exprColonEqExprList2 optPar ']'
        | '{' optInd exprColonEqExprList2 optPar '}'
        | ('`'|IDENT|literal|'cast'|'addr'|'type') expr // command syntax
condExpr ::= expr colcom expr optInd ('elif' expr colcom expr optInd)* 'else' colcom expr
ifExpr ::= 'if' condExpr
whenExpr ::= 'when' condExpr
pragma ::= '{.' optInd (exprColonEqExpr comma?)* optPar ('.}'|'}')
identVis ::= symbol OPR? // postfix position
identVisDot ::= symbol '.' optInd symbol OPR?
identWithPragma ::= identVis pragma?
identWithPragmaDot ::= identVisDot pragma?
declColonEquals ::= identWithPragma (comma identWithPragma)* comma? (':' optInd typeDesc)? ('=' optInd expr)?
identColonEquals ::= IDENT (comma IDENT)* comma? (':' optInd typeDesc)? ('=' optInd expr)?
paramList ::= '(' (declColonEquals ((comma|semicolon) declColonEquals)*)? ')'
paramListArrow ::= paramList? ('->' optInd typeDesc)?
paramListColon ::= paramList? (':' optInd typeDesc)?
doBlock ::= 'do' paramListArrow pragma? colcom stmt
forStmt ::= 'for' (identWithPragma (comma identWithPragma)*) 'in' expr colcom stmt
forExpr ::= forStmt
expr ::= (blockExpr|ifExpr|whenExpr|caseStmt|forExpr|tryExpr)|simpleExpr
typeKeyw ::= 'var'|'out'|'ref'|'ptr'|'shared'|'tuple'|'proc'|'iterator'|'distinct'|'object'|'enum'
primary ::= typeKeyw optInd typeDesc | prefixOperator* identOrLiteral primarySuffix* | 'bind' primary
typeDesc ::= simpleExpr ('not' expr)?
typeDefAux ::= simpleExpr ('not' expr)?|'concept' typeClass
postExprBlocks ::= ':' stmt? ( IND_EQ doBlock
                             | IND_EQ 'of' exprList ':' stmt
                             | IND_EQ 'elif' expr ':' stmt
                             | IND_EQ 'except' exprList ':' stmt
                             | IND_EQ 'else' ':' stmt )*
exprStmt ::= simpleExpr (( '=' optInd expr colonBody? )|( expr (comma expr)* postExprBlocks ))?
importStmt ::= 'import' optInd expr ((comma expr)+|'except' optInd (expr (comma expr)*))
exportStmt ::= 'export' optInd expr ((comma expr)+|'except' optInd (expr (comma expr)*))
includeStmt ::= 'include' optInd expr (comma expr)*
fromStmt ::= 'from' expr 'import' optInd expr (comma expr)*
returnStmt ::= 'return' optInd expr?
raiseStmt ::= 'raise' optInd expr?
yieldStmt ::= 'yield' optInd expr?
discardStmt ::= 'discard' optInd expr?
breakStmt ::= 'break' optInd expr?
continueStmt ::= 'break' optInd expr?
condStmt ::= expr colcom stmt COMMENT? (IND_EQ 'elif' expr colcom stmt)* (IND_EQ 'else' colcom stmt)?
ifStmt ::= 'if' condStmt
whenStmt ::= 'when' condStmt
whileStmt ::= 'while' expr colcom stmt
ofBranch ::= 'of' exprList colcom stmt
ofBranches ::= ofBranch (IND_EQ ofBranch)* (IND_EQ 'elif' expr colcom stmt)* (IND_EQ 'else' colcom stmt)?
caseStmt ::= 'case' expr ':'? COMMENT? (IND_GT ofBranches IND_LT|IND_EQ ofBranches)
tryStmt ::= 'try' colcom stmt (IND_EQ? 'except'|'finally')
             (IND_EQ? 'except' exprList colcom stmt)*
             (IND_EQ? 'finally' colcom stmt)?
tryExpr ::= 'try' colcom stmt (optInd 'except'|'finally')
             (optInd 'except' exprList colcom stmt)*
             (optInd 'finally' colcom stmt)?
blockStmt ::= 'block' symbol? colcom stmt
blockExpr ::= 'block' symbol? colcom stmt
staticStmt ::= 'static' colcom stmt
deferStmt ::= 'defer' colcom stmt
asmStmt ::= 'asm' pragma? (STR_LIT|RSTR_LIT|TRIPLESTR_LIT)
genericParam ::= symbol (comma symbol)* (colon expr)? ('=' optInd expr)?
genericParamList ::= '[' optInd (genericParam ((comma|semicolon) genericParam)*)? optPar ']'
pattern ::= '{' stmt '}'
indAndComment ::= ((IND_GT COMMENT)|COMMENT)?
routine ::= optInd identVis pattern? genericParamList? paramListColon pragma? ('=' COMMENT? stmt)? indAndComment
commentStmt ::= COMMENT
private meta section ::= COMMENT? <<RULE>>|(IND_GT (<<RULE>>|COMMENT) (IND_EQ (<<RULE>>|COMMENT))* IND_LT)
typeClassParam ::= ('var'|'out')? symbol
typeClass ::= (typeClassParam (',' typeClassParam)*)? (pragma)? ('of' (typeDesc (',' typeDesc)*)?)? IND_GT stmt
typeDef ::= identWithPragmaDot genericParamList? '=' optInd typeDefAux
              indAndComment?|identVisDot genericParamList? pragma '=' optInd typeDefAux
              indAndComment?
varTuple ::= '(' optInd identWithPragma (comma identWithPragma)* optPar ')' '=' optInd expr
colonBody ::= colcom stmt postExprBlocks?
variable ::= (varTuple|identColonEquals) colonBody? indAndComment
constant ::= (varTuple|identWithPragma) (colon typeDesc)? '=' optInd expr indAndComment
bindStmt ::= 'bind' optInd qualifiedIdent (comma qualifiedIdent)*
mixinStmt ::= 'mixin' optInd qualifiedIdent (comma qualifiedIdent)*
pragmaStmt ::= pragma (':' COMMENT? stmt)?
simpleStmt ::= ((returnStmt|raiseStmt|yieldStmt|discardStmt|breakStmt
             | continueStmt|pragmaStmt|importStmt|exportStmt|fromStmt
             | includeStmt|commentStmt)|exprStmt) COMMENT?
complexOrSimpleStmt ::= (ifStmt|whenStmt|whileStmt
                      | tryStmt|forStmt
                      | blockStmt|staticStmt|deferStmt|asmStmt
                      | 'proc' routine
                      | 'func' routine
                      | 'method' routine
                      | 'iterator' routine
                      | 'macro' routine
                      | 'template' routine
                      | 'converter' routine
                      | 'type' <<section typeDef>>
                      | 'const' <<section constant>>
                      | ('let'|'var'|'using') <<section variable>>
                      | bindStmt|mixinStmt)
                      | simpleStmt
stmt ::= (IND_GT complexOrSimpleStmt ((IND_EQ|';') complexOrSimpleStmt)* IND_LT)
       | simpleStmt (';' simpleStmt)*
