/*
 * This file is based on example provided by the IntelliJ Platform SDK DevGuide.
 * Copyright 2000-2020 JetBrains s.r.o. and other contributors.
 * Use of original example source code is governed by the Apache 2.0 license.
 *
 * Copyright 2020 TiePy Ltd. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This file is part of Nimatron, a Nim plug-in for IDEA platform IDEs.
 *
 * Nimatron is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.  TiePy Ltd designates this
 * particular file as subject to the "Classpath" exception as provided
 * by TiePy Ltd in the LICENSE file that accompanied this code.
 *
 * Nimatron is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Nimatron.  If not, see <https://www.gnu.org/licenses/>.
 *
 * Please contact TiePy Ltd, 19 Lyall Way, Laurencekirk, AB30 1FU, UK
 * or visit www.tiepy.com if you need additional information or have any
 * questions.
 */

{
  parserClass="com.tiepy.nimatron.parser.NimParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Nim"
  psiImplClassSuffix="Impl"
  psiPackage="com.tiepy.nimatron.parser"
  psiImplPackage="com.tiepy.nimatron.parser.impl"

  elementTypeHolderClass="com.tiepy.nimatron.parser.NimTypes"
  elementTypeClass="com.tiepy.nimatron.psi.NimElementType"
  tokenTypeClass="com.tiepy.nimatron.psi.NimTokenType"

  tokens = [
    BRACKET="BRACKET"
    PARENTHESIS="PARENTHESIS"
    C_SEMICOLON="C_SEMICOLON"
    C_COMMA="C_COMMA"
    C_GRAVE_ACCENT="C_GRAVE_ACCENT"
  ]

  psiImplUtilClass="com.tiepy.nimatron.parser.impl.NimPsiImplUtil"
}

module ::= IND_EQ* (stmt ((';'|IND_EQ) stmt)*)? ';'? IND_EQ*
operator ::= OP0|OP1|OP2|OP3|OP4|OP5|OP6|OP7|OP8|OP9|'from'|'static'|'..'
optInd ::= (IND_GT|IND_EQ)?
simpleExpr ::= arrowExpr (OP0 optInd arrowExpr)* pragma?
arrowExpr ::= assignExpr (OP1 optInd assignExpr)*
assignExpr ::= orExpr (OP2 optInd orExpr)*
orExpr ::= andExpr (OP3 optInd andExpr)*
andExpr ::= cmpExpr (OP4 optInd cmpExpr)*
cmpExpr ::= sliceExpr (OP5 optInd sliceExpr)*
sliceExpr ::= ampExpr (OP6 optInd ampExpr)*
ampExpr ::= plusExpr (OP7 optInd plusExpr)*
plusExpr ::= mulExpr (OP8 optInd mulExpr)*
mulExpr ::= dollarExpr (OP9 optInd dollarExpr)*
dollarExpr ::= primary (OP10 optInd primary)*
symbol ::= '`' (KEYW|IDENT|literal|operator|'('|')'|'['|']'|'{'|'}'|'=')+ '`'|IDENT|KEYW
exprColonEqExpr ::= expr (':'|'=' expr)?
exprList ::= expr (',' expr)*
exprColonEqExprList2 ::= exprColonEqExpr (',' exprColonEqExpr)* ','?
qualifiedIdent ::= symbol ('.' optInd symbol)?
setOrTableConstr ::= '{' ((exprColonEqExpr ',')+ | ':') '}'
castExpr ::= 'cast' '[' optInd typeDesc optInd ']' '(' optInd expr optInd ')'
//parKeyw ::= 'discard'|'include'|'if'|'while'|'case'|'try'|'finally'|'except'|'for'|'block'|'const'|'let'|'when'|'var'|'mixin'
par ::= '(' optInd ( /*&parKeyw*/ complexOrSimpleStmt (';' complexOrSimpleStmt)*
            | ';' complexOrSimpleStmt (';' complexOrSimpleStmt)*
            | pragmaStmt
            | simpleExpr ( ('=' expr (';' complexOrSimpleStmt (';' complexOrSimpleStmt)* )? )
                         | (':' expr (',' exprColonEqExpr (',' exprColonEqExpr)* )? ) ) ) optInd ')'
literal ::= INT_LIT|INT8_LIT|INT16_LIT|INT32_LIT|INT64_LIT
            |UINT_LIT|UINT8_LIT|UINT16_LIT|UINT32_LIT|UINT64_LIT
            |FLOAT_LIT|FLOAT32_LIT|FLOAT64_LIT
            |STR_LIT|RSTR_LIT|TRIPLESTR_LIT
            |CHAR_LIT
            |NIL
generalizedLit ::= GENERALIZED_STR_LIT|GENERALIZED_TRIPLESTR_LIT
identOrLiteral ::= generalizedLit|symbol|literal|par|arrayConstr|setOrTableConstr|castExpr
arrayConstr ::= '[' optInd (exprColonEqExpr ','?)* optInd ']'
primarySuffix ::= '(' (exprColonEqExpr ','?)* ')'
        | '.' optInd symbol generalizedLit?
        | '[' optInd exprColonEqExprList2 optInd ']'
        | '{' optInd exprColonEqExprList2 optInd '}'
        | /*&('`'|IDENT|literal|'cast'|'addr'|'type')*/ expr // command syntax
condExpr ::= expr ':' expr optInd ('elif' expr ':' expr optInd)* 'else' ':' expr
ifExpr ::= 'if' condExpr
whenExpr ::= 'when' condExpr
pragma ::= '{.' optInd (exprColonEqExpr ','?)* optInd ('.}'|'}')
identVis ::= symbol OPR? // postfix position
identVisDot ::= symbol '.' optInd symbol OPR?
identWithPragma ::= identVis pragma?
identWithPragmaDot ::= identVisDot pragma?
declColonEquals ::= identWithPragma (',' identWithPragma)* ','? (':' optInd typeDesc)? ('=' optInd expr)?
identColonEquals ::= IDENT (',' IDENT)* ','? (':' optInd typeDesc)? ('=' optInd expr)?
paramList ::= '(' (declColonEquals ((','|';') declColonEquals)*)? ')'
paramListArrow ::= paramList? ('->' optInd typeDesc)?
paramListColon ::= paramList? (':' optInd typeDesc)?
doBlock ::= 'do' paramListArrow pragma? ':' stmt
forStmt ::= 'for' (identWithPragma (',' identWithPragma)*) 'in' expr ':' stmt
expr ::= blockExpr|ifExpr|whenExpr|caseStmt|forStmt|tryExpr|simpleExpr
typeKeyw ::= 'var'|'out'|'ref'|'ptr'|'shared'|'tuple'|'proc'|'iterator'|'distinct'|'object'|'enum'
primary ::= (typeKeyw optInd typeDesc) | (operator* identOrLiteral primarySuffix*) | ('bind' primary)
typeDesc ::= simpleExpr ('not' expr)?
typeDefAux ::= simpleExpr ('not' expr)? | 'concept' typeClass
postExprBlocks ::= ':' stmt? ( IND_EQ doBlock
                             | IND_EQ 'of' exprList ':' stmt
                             | IND_EQ 'elif' expr ':' stmt
                             | IND_EQ 'except' exprList ':' stmt
                             | IND_EQ 'else' ':' stmt )*
exprStmt ::= simpleExpr (('=' optInd expr colonBody?) | (expr (',' expr)* postExprBlocks))?
importStmt ::= 'import' optInd expr ((',' expr)+ | 'except' optInd (expr (',' expr)*))
exportStmt ::= 'export' optInd expr ((',' expr)+ | 'except' optInd (expr (',' expr)*))
includeStmt ::= 'include' optInd expr (',' expr)*
fromStmt ::= 'from' expr 'import' optInd expr (',' expr)*
returnStmt ::= 'return' optInd expr?
raiseStmt ::= 'raise' optInd expr?
yieldStmt ::= 'yield' optInd expr?
discardStmt ::= 'discard' optInd expr?
breakStmt ::= 'break' optInd expr?
continueStmt ::= 'break' optInd expr?
condStmt ::= expr ':' stmt (IND_EQ 'elif' expr ':' stmt)* (IND_EQ 'else' ':' stmt)?
ifStmt ::= 'if' condStmt
whenStmt ::= 'when' condStmt
whileStmt ::= 'while' expr ':' stmt
ofBranch ::= 'of' exprList ':' stmt
ofBranches ::= ofBranch (IND_EQ ofBranch)* (IND_EQ 'elif' expr ':' stmt)* (IND_EQ 'else' ':' stmt)?
caseStmt ::= 'case' expr ':'? (IND_GT ofBranches IND_LT|IND_EQ ofBranches)
tryStmt ::= 'try' ':' stmt /*&(IND_EQ? 'except'|'finally')*/
             (IND_EQ? 'except' exprList ':' stmt)*
             (IND_EQ? 'finally' ':' stmt)?
tryExpr ::= 'try' ':' stmt /*&(optInd 'except'|'finally')*/
             (optInd 'except' exprList ':' stmt)*
             (optInd 'finally' ':' stmt)?
blockStmt ::= 'block' symbol? ':' stmt
blockExpr ::= 'block' symbol? ':' stmt
staticStmt ::= 'static' ':' stmt
deferStmt ::= 'defer' ':' stmt
asmStmt ::= 'asm' pragma? (STR_LIT|RSTR_LIT|TRIPLESTR_LIT)
genericParam ::= symbol (',' symbol)* (':' expr)? ('=' optInd expr)?
genericParamList ::= '[' optInd (genericParam ((','|';') genericParam)*)? optInd ']'
pattern ::= '{' stmt '}'
routine ::= optInd identVis pattern? genericParamList? paramListColon pragma? ('=' stmt)?
private meta section ::= <<RULE>> | (IND_GT (<<RULE>>)? (IND_EQ (<<RULE>>)?)* IND_LT)
typeClassParam ::= ('var'|'out')? symbol
typeClass ::= (typeClassParam (',' typeClassParam)*)? (pragma)? ('of' (typeDesc (',' typeDesc)*)?)? /*&IND_GT stmt*/
typeDef ::= identWithPragmaDot genericParamList? '=' optInd typeDefAux
              identVisDot genericParamList? pragma '=' optInd typeDefAux
varTuple ::= '(' optInd identWithPragma (',' identWithPragma)* optInd ')' '=' optInd expr
colonBody ::= ':' stmt postExprBlocks?
variable ::= (varTuple|identColonEquals) colonBody?
constant ::= (varTuple|identWithPragma) (':' typeDesc)? '=' optInd expr
bindStmt ::= 'bind' optInd qualifiedIdent (',' qualifiedIdent)*
mixinStmt ::= 'mixin' optInd qualifiedIdent (',' qualifiedIdent)*
pragmaStmt ::= pragma (':' stmt)?
simpleStmt ::= ((returnStmt|raiseStmt|yieldStmt|discardStmt|breakStmt
             | continueStmt|pragmaStmt|importStmt|exportStmt|fromStmt
             | includeStmt)|exprStmt)
complexOrSimpleStmt ::= (ifStmt|whenStmt|whileStmt
                      | tryStmt|forStmt
                      | blockStmt|staticStmt|deferStmt|asmStmt
                      | 'proc' routine
                      | 'func' routine
                      | 'method' routine
                      | 'iterator' routine
                      | 'macro' routine
                      | 'template' routine
                      | 'converter' routine
                      | 'type' <<section typeDef>>
                      | 'const' <<section constant>>
                      | ('let'|'var'|'using') <<section variable>>
                      | bindStmt|mixinStmt)
                      | simpleStmt
stmt ::= (IND_GT complexOrSimpleStmt ((IND_EQ|';') complexOrSimpleStmt)* IND_LT) | simpleStmt
